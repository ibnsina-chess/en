<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Dark Knights Ibn Sina - Chess Game</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <style>
        /* General Styles */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Authentication Section */
        #auth-section {
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        #qr-scanner-btn {
            background-color: #81B64C;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        #qr-scanner-btn:hover {
            background-color: #6a9a3d;
        }

        /* Chess Game Section */
        #game-section {
            display: none;
            margin-top: 20px;
        }

        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }

        .board-container {
            width: 500px;
            max-width: 100%;
        }

        .game-info {
            width: 300px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .player-info {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .game-status {
            font-weight: bold;
            margin: 15px 0;
            color: #333;
        }

        .game-controls button {
            background-color: #81B64C;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .game-controls button:hover {
            background-color: #6a9a3d;
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        /* Opponent Selection */
        #opponent-section {
            display: none;
            margin-top: 20px;
            text-align: center;
        }

        #opponent-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .opponent-card {
            width: 150px;
            background-color: #fff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .opponent-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transform: translateY(-5px);
        }

        .opponent-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto;
            display: block;
        }

        .opponent-name {
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
        }

        .opponent-elo {
            color: #666;
            text-align: center;
        }

        /* Game Room Section */
        #room-section {
            display: none;
            margin-top: 20px;
            text-align: center;
        }

        .room-info {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .room-url {
            padding: 10px;
            background-color: #e9e9e9;
            border-radius: 5px;
            font-family: monospace;
            word-break: break-all;
            margin: 10px 0;
        }

        .copy-btn {
            background-color: #81B64C;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background-color: #6a9a3d;
        }

        /* Media Queries */
        @media (max-width: 768px) {
            .board-container {
                width: 100%;
            }

            .game-info {
                width: 100%;
            }
        }

        /* Loader */
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #81B64C;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        /* Game Results */
        #game-results {
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }

        #game-results h3 {
            color: #333;
            margin-top: 0;
        }

        .result-detail {
            margin: 10px 0;
        }

        .elo-change {
            font-weight: bold;
        }

        .positive-elo {
            color: green;
        }

        .negative-elo {
            color: red;
        }

        /* Chat box */
        .chat-box {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
        }

        .chat-messages {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f9f9f9;
        }

        .chat-input-container {
            display: flex;
            border-top: 1px solid #ddd;
        }

        .chat-input {
            flex-grow: 1;
            padding: 10px;
            border: none;
            outline: none;
        }

        .chat-send-btn {
            background-color: #81B64C;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
        }

        .chat-send-btn:hover {
            background-color: #6a9a3d;
        }

        .message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 5px;
        }

        .message-self {
            background-color: #e1f3d8;
            text-align: right;
        }

        .message-other {
            background-color: #e9e9e9;
            text-align: left;
        }

        .message-system {
            background-color: #f0f0f0;
            text-align: center;
            font-style: italic;
        }

        .message-sender {
            font-weight: bold;
            margin-bottom: 3px;
        }

        /* Game status */
        .waiting-banner {
            background-color: #ffeeba;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            text-align: center;
        }

        .player-turn-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .turn-white {
            background-color: white;
            border: 1px solid #ddd;
        }

        .turn-black {
            background-color: black;
        }

        /* Move list */
        .move-list {
            padding: 0;
            list-style-type: none;
        }

        .move-list li {
            padding: 3px 0;
        }

        .move-list li:nth-child(odd) {
            background-color: #f5f5f5;
        }
    </style>
</head>
<body>
    <nav>
        <img src="https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png" alt="" class="logo">
        <div class="menu-toggle" onclick="toggleMenu()">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <ul>
            <li><a href="index.html">home</a></li>
            <li><a href="members.html">members</a></li>
            <li><a href="classification.html">Classification</a></li>
            <li><a href="evolution.html">Evolution</a></li>
            <li><a href="blog.html">blog</a></li>
        </ul>
    </nav>

    <div class="container">
        <div id="auth-section">
            <h2>The Dark Knights Ibn Sina Chess Game</h2>
            <p>Scan your membership QR code to login and play chess with other members.</p>
            <button id="qr-scanner-btn"><i class="fas fa-qrcode"></i> Scan QR Code</button>
            <div id="login-status"></div>
        </div>

        <div id="opponent-section">
            <h2>Select an Opponent</h2>
            <p>Choose a member to play against or create a new game room:</p>
            <div class="game-controls">
                <button id="create-room-btn"><i class="fas fa-plus-circle"></i> Create New Game Room</button>
            </div>
            <div id="opponent-list">
                <!-- Opponents will be populated here -->
                <div class="loader" id="opponent-loader"></div>
            </div>
        </div>

        <div id="room-section">
            <h2>Game Room</h2>
            <div class="room-info">
                <h3>Share this link with your opponent</h3>
                <div class="room-url" id="room-url"></div>
                <button class="copy-btn" id="copy-url-btn"><i class="fas fa-copy"></i> Copy Link</button>
                <p>Waiting for opponent to join...</p>
                <div class="loader"></div>
                <button class="game-controls" id="cancel-room-btn">Cancel Room</button>
            </div>
        </div>

        <div id="game-section">
            <h2>Chess Game</h2>
            <div id="waiting-message" class="waiting-banner">Waiting for opponent to make a move...</div>
            <div class="game-container">
                <div class="board-container">
                    <div id="board"></div>
                </div>
                <div class="game-info">
                    <div class="player-info" id="opponent-info">
                        <img class="player-avatar" id="opponent-avatar" src="https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png" alt="Opponent">
                        <div>
                            <div id="opponent-name">Opponent</div>
                            <div id="opponent-elo">ELO: ----</div>
                        </div>
                    </div>
                    <div class="player-info" id="player-info">
                        <img class="player-avatar" id="player-avatar" src="https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png" alt="You">
                        <div>
                            <div id="player-name">You</div>
                            <div id="player-elo">ELO: ----</div>
                        </div>
                    </div>
                    <div class="game-status" id="status">Waiting for game to start...</div>
                    <div class="game-controls">
                        <button id="resign-btn">Resign</button>
                        <button id="offer-draw-btn">Offer Draw</button>
                        <button id="new-game-btn">New Game</button>
                    </div>
                    <div class="move-history">
                        <h4>Move History</h4>
                        <ul id="move-history" class="move-list"></ul>
                    </div>
                    
                    <div class="chat-box">
                        <div class="chat-messages" id="chat-messages"></div>
                        <div class="chat-input-container">
                            <input type="text" class="chat-input" id="chat-input" placeholder="Type a message...">
                            <button class="chat-send-btn" id="chat-send-btn"><i class="fas fa-paper-plane"></i></button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="game-results">
            <h3>Game Results</h3>
            <div id="result-details"></div>
            <div class="game-controls">
                <button id="play-again-btn">Play Again</button>
                <button id="find-new-opponent-btn">Find New Opponent</button>
            </div>
        </div>
    </div>

    <!-- QR Scanner Modal -->
    <div id="qr-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h3>Scan QR Code</h3>
            <p>Please enter the URL from your membership card QR code:</p>
            <input type="text" id="qr-input" placeholder="https://ibnsina-chess.github.io/en/member.html?id=XXXX-XXXX-XXXX">
            <button id="submit-qr">Submit</button>
        </div>
    </div>

    <!-- Join Room Modal -->
    <div id="join-room-modal" class="modal">
        <div class="modal-content">
            <span class="close join-close">&times;</span>
            <h3>Join Chess Game</h3>
            <p>You've been invited to a chess game. Would you like to join?</p>
            <div class="game-controls">
                <button id="confirm-join-btn">Join Game</button>
                <button id="decline-join-btn">Decline</button>
            </div>
        </div>
    </div>

    <footer>
        <div class="horizontal-div">
            <img src="https://i.ibb.co/xr0mz7L/buil-by.png" alt="">
            <a href="https://github.com/abdelhakim-sahifa"> <i class="fa-brands fa-github"></i></a>
        </div>
        <ul class="footer-links">
            <li><a href="members.html">members</a></li>
            <li><a href="classification.html">Classification</a></li>
            <li><a href="evolution.html">Evolution</a></li>
            <li><a href="blog.html">blog</a></li>
        </ul>
        <p>&copy; 2024 THE DARK KNIGHTS IBN SINA. All rights reserved.</p>
    </footer>

 <script type="module">
    
// Firebase Configuration
const firebaseConfig = {
    apiKey: "AIzaSyCd9XbhKz-AYvVJtLCi2hVDBvyYsSGB89w",
    authDomain: "chess-3596b.firebaseapp.com",
    databaseURL: "https://chess-3596b-default-rtdb.firebaseio.com",
    projectId: "chess-3596b",
    storageBucket: "chess-3596b.firebasestorage.app",
    messagingSenderId: "628293480183",
    appId: "1:628293480183:web:ecd5f317c728cd1233edf2",
    measurementId: "G-11H7GE4LT7"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();
const auth = firebase.auth();

// Global variables
let currentUser = null;
let currentUserId = null;
let currentUserName = null;
let currentUserElo = 1200;
let currentUserAvatar = null;
let selectedOpponent = null;
let selectedOpponentName = null;
let selectedOpponentAvatar = null;
let selectedOpponentElo = 1200;
let board = null;
let game = null;
let gameId = null;
let roomId = null;
let playerColor = 'white';
let isMyTurn = false;
let gameStarted = false;
let drawOffered = false;
let chatMessages = [];

// DOM Elements
const qrScannerBtn = document.getElementById('qr-scanner-btn');
const qrModal = document.getElementById('qr-modal');
const closeModal = document.querySelector('.close');
const joinCloseModal = document.querySelector('.join-close');
const submitQrBtn = document.getElementById('submit-qr');
const qrInput = document.getElementById('qr-input');
const loginStatus = document.getElementById('login-status');
const opponentSection = document.getElementById('opponent-section');
const opponentList = document.getElementById('opponent-list');
const opponentLoader = document.getElementById('opponent-loader');
const gameSection = document.getElementById('game-section');
const roomSection = document.getElementById('room-section');
const roomUrlElement = document.getElementById('room-url');
const copyUrlBtn = document.getElementById('copy-url-btn');
const cancelRoomBtn = document.getElementById('cancel-room-btn');
const createRoomBtn = document.getElementById('create-room-btn');
const statusElement = document.getElementById('status');
const moveHistoryElement = document.getElementById('move-history');
const resignBtn = document.getElementById('resign-btn');
const offerDrawBtn = document.getElementById('offer-draw-btn');
const newGameBtn = document.getElementById('new-game-btn');
const gameResultsElement = document.getElementById('game-results');
const resultDetailsElement = document.getElementById('result-details');
const playAgainBtn = document.getElementById('play-again-btn');
const findNewOpponentBtn = document.getElementById('find-new-opponent-btn');
const opponentNameElement = document.getElementById('opponent-name');
const opponentEloElement = document.getElementById('opponent-elo');
const playerNameElement = document.getElementById('player-name');
const playerEloElement = document.getElementById('player-elo');
const opponentAvatarElement = document.getElementById('opponent-avatar');
const playerAvatarElement = document.getElementById('player-avatar');
const waitingMessage = document.getElementById('waiting-message');
const joinRoomModal = document.getElementById('join-room-modal');
const confirmJoinBtn = document.getElementById('confirm-join-btn');
const declineJoinBtn = document.getElementById('decline-join-btn');
const chatMessagesElement = document.getElementById('chat-messages');
const chatInput = document.getElementById('chat-input');
const chatSendBtn = document.getElementById('chat-send-btn');

// Check if we're joining a room from a URL
window.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    roomId = urlParams.get('room');
    
    if (roomId) {
        // We're joining an existing game
        auth.onAuthStateChanged((user) => {
            if (user) {
                // User is already signed in
                checkRoomValidity(roomId);
            } else {
                // Show login modal, but don't redirect after login
                showLoginForJoining();
            }
        });
    }
});

// Show login modal for joining a game
function showLoginForJoining() {
    document.getElementById('auth-section').style.display = 'block';
    loginStatus.innerHTML = '<p>Please login to join this chess game.</p>';
}

// Check if the room is valid and available to join
function checkRoomValidity(roomId) {
    database.ref('chess_rooms/' + roomId).once('value')
        .then((snapshot) => {
            const roomData = snapshot.val();
            if (!roomData) {
                alert('This game room no longer exists.');
                window.location.href = 'game.html';
                return;
            }
            
            if (roomData.status === 'waiting') {
                // Room is available to join
                showJoinRoomModal(roomData);
            } else if (roomData.status === 'active') {
                // Check if the current user is a participant
                if (roomData.player1 === currentUser.uid || roomData.player2 === currentUser.uid) {
                    joinActiveGame(roomId, roomData);
                } else {
                    alert('This game is already in progress between two other players.');
                    window.location.href = 'game.html';
                }
            } else if (roomData.status === 'completed') {
                alert('This game has already ended.');
                window.location.href = 'game.html';
            }
        })
        .catch((error) => {
            console.error('Error checking room:', error);
            alert('Error accessing the game room.');
            window.location.href = 'game.html';
        });
}

// Show modal to confirm joining the room
function showJoinRoomModal(roomData) {
    joinRoomModal.style.display = 'block';
    
    confirmJoinBtn.addEventListener('click', () => {
        joinRoomModal.style.display = 'none';
        joinRoom(roomId, roomData);
    });
    
    declineJoinBtn.addEventListener('click', () => {
        joinRoomModal.style.display = 'none';
        window.location.href = 'game.html';
    });
}

// Join a room as player 2
function joinRoom(roomId, roomData) {
    // Update room status
    database.ref('chess_rooms/' + roomId).update({
        player2: currentUser.uid,
        player2Name: currentUserName,
        player2Elo: currentUserElo,
        player2Avatar: currentUserAvatar,
        status: 'active',
        lastActivity: Date.now()
    })
    .then(() => {
        playerColor = 'black';
        selectedOpponent = roomData.player1;
        selectedOpponentName = roomData.player1Name;
        selectedOpponentElo = roomData.player1Elo;
        selectedOpponentAvatar = roomData.player1Avatar;
        
        // Show game section
        document.getElementById('auth-section').style.display = 'none';
        opponentSection.style.display = 'none';
        gameSection.style.display = 'block';
        
        // Update player info
        updatePlayerInfo();
        
        // Initialize game
        initGame();
        
        // Add system message to chat
        addSystemMessage('You joined the game as Black');
        addSystemMessage('Game started!');
        
        // Add game start message to database
        const messageData = {
            sender: 'system',
            text: `${currentUserName} joined the game as Black. Game started!`,
            timestamp: Date.now()
        };
        database.ref('chess_rooms/' + roomId + '/chat').push(messageData);
        
        // Set up listeners for this game
        setupGameListeners();
    })
    .catch((error) => {
        console.error('Error joining room:', error);
        alert('Error joining the game.');
    });
}

// Join an active game (reconnecting)
function joinActiveGame(roomId, roomData) {
    // Determine which player is the current user
    if (roomData.player1 === currentUser.uid) {
        playerColor = 'white';
        selectedOpponent = roomData.player2;
        selectedOpponentName = roomData.player2Name;
        selectedOpponentElo = roomData.player2Elo;
        selectedOpponentAvatar = roomData.player2Avatar;
    } else {
        playerColor = 'black';
        selectedOpponent = roomData.player1;
        selectedOpponentName = roomData.player1Name;
        selectedOpponentElo = roomData.player1Elo;
        selectedOpponentAvatar = roomData.player1Avatar;
    }
    
    // Show game section
    document.getElementById('auth-section').style.display = 'none';
    opponentSection.style.display = 'none';
    gameSection.style.display = 'block';
    
    // Update player info
    updatePlayerInfo();
    
    // Initialize game with current state
    initGame(roomData.fen);
    
    // Add system message to chat
    addSystemMessage('Reconnected to game');
    
    // Set up listeners for this game
    setupGameListeners();
}

// QR Scanner functionality
qrScannerBtn.addEventListener('click', () => {
    qrModal.style.display = 'block';
});

closeModal.addEventListener('click', () => {
    qrModal.style.display = 'none';
});

joinCloseModal.addEventListener('click', () => {
    joinRoomModal.style.display = 'none';
    window.location.href = 'game.html';
});

window.addEventListener('click', (event) => {
    if (event.target === qrModal) {
        qrModal.style.display = 'none';
    } else if (event.target === joinRoomModal) {
        joinRoomModal.style.display = 'none';
        window.location.href = 'game.html';
    }
});

submitQrBtn.addEventListener('click', processQrCode);

// Continue from where the previous code ended

// Process QR code and authenticate
function processQrCode() {
const qrUrl = qrInput.value.trim();

// Validate URL format
if (!qrUrl.includes('member.html?id=')) {
loginStatus.innerHTML = '<p style="color: red;">Invalid QR code URL. Please try again.</p>';
return;
}

// Extract member ID from URL
const memberIdMatch = qrUrl.match(/id=([^&]*)/);
if (!memberIdMatch) {
loginStatus.innerHTML = '<p style="color: red;">Could not extract ID from URL. Please try again.</p>';
return;
}

const memberId = memberIdMatch[1];
currentUserId = memberId;

// Get member information from Firebase
database.ref('members/' + memberId).once('value')
.then((snapshot) => {
    const memberData = snapshot.val();
    if (!memberData) {
        loginStatus.innerHTML = '<p style="color: red;">Member not found. Please check your QR code.</p>';
        return;
    }

    // Extract name for email creation
    const nameParts = memberId.split('-');
    // Remove the first part (ID number)
    const nameForEmail = nameParts.slice(1).join('-');
    const email = `${nameForEmail}@ibnsinachess.com`;
    const password = memberId; // Using ID as password

    // Check if user exists in Firebase Auth
    auth.fetchSignInMethodsForEmail(email)
        .then((signInMethods) => {
            if (signInMethods.length === 0) {
                // Create new user if doesn't exist
                auth.createUserWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        // Store additional user info
                        currentUser = userCredential.user;
                        currentUserName = memberData.name || 'Anonymous Player';
                        currentUserElo = memberData.elo || 1200;
                        currentUserAvatar = memberData.avatar || 'https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png';
                        
                        // Update user profile
                        return userCredential.user.updateProfile({
                            displayName: currentUserName
                        });
                    })
                    .then(() => {
                        // Save additional user data to database
                        return database.ref('users/' + currentUser.uid).set({
                            memberId: memberId,
                            name: currentUserName,
                            elo: currentUserElo,
                            avatar: currentUserAvatar,
                            gamesPlayed: 0,
                            wins: 0,
                            losses: 0,
                            draws: 0
                        });
                    })
                    .then(() => {
                        loginSuccess();
                    })
                    .catch((error) => {
                        loginStatus.innerHTML = `<p style="color: red;">Error creating account: ${error.message}</p>`;
                    });
            } else {
                // Sign in existing user
                auth.signInWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        currentUser = userCredential.user;
                        // Get updated user data
                        return database.ref('users/' + currentUser.uid).once('value');
                    })
                    .then((snapshot) => {
                        const userData = snapshot.val();
                        if (userData) {
                            currentUserName = userData.name || 'Anonymous Player';
                            currentUserElo = userData.elo || 1200;
                            currentUserAvatar = userData.avatar || 'https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png';
                        }
                        loginSuccess();
                    })
                    .catch((error) => {
                        loginStatus.innerHTML = `<p style="color: red;">Login error: ${error.message}</p>`;
                    });
            }
        })
        .catch((error) => {
            loginStatus.innerHTML = `<p style="color: red;">Authentication error: ${error.message}</p>`;
        });
})
.catch((error) => {
    loginStatus.innerHTML = `<p style="color: red;">Database error: ${error.message}</p>`;
});
}

// Handle successful login
function loginSuccess() {
loginStatus.innerHTML = '<p style="color: green;">Login successful! Redirecting...</p>';
qrModal.style.display = 'none';
document.getElementById('auth-section').style.display = 'none';

// Check if we're joining a room
if (roomId) {
checkRoomValidity(roomId);
} else {
// Show opponent selection
loadOpponents();
opponentSection.style.display = 'block';
}
}

// Load online opponents
function loadOpponents() {
opponentLoader.style.display = 'block';
opponentList.innerHTML = '';

// Get all users except current user
database.ref('users').once('value')
.then((snapshot) => {
    const users = snapshot.val();
    let foundOpponents = false;
    
    // Clear the loader
    opponentLoader.style.display = 'none';
    
    for (const userId in users) {
        if (userId !== currentUser.uid) {
            const user = users[userId];
            const opponentCard = document.createElement('div');
            opponentCard.className = 'opponent-card';
            opponentCard.innerHTML = `
                <img src="${user.avatar || 'https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png'}" alt="${user.name}" class="opponent-avatar">
                <div class="opponent-name">${user.name}</div>
                <div class="opponent-elo">ELO: ${user.elo || 1200}</div>
            `;
            
            // Add click event
            opponentCard.addEventListener('click', () => {
                selectedOpponent = userId;
                selectedOpponentName = user.name;
                selectedOpponentElo = user.elo || 1200;
                selectedOpponentAvatar = user.avatar || 'https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png';
                createGameRoom();
            });
            
            opponentList.appendChild(opponentCard);
            foundOpponents = true;
        }
    }
    
    if (!foundOpponents) {
        opponentList.innerHTML = '<p>No other members are registered yet. Create a room and share the link!</p>';
    }
})
.catch((error) => {
    console.error('Error loading opponents:', error);
    opponentLoader.style.display = 'none';
    opponentList.innerHTML = '<p>Error loading opponents. Please try again.</p>';
});
}

// Create new game room button
createRoomBtn.addEventListener('click', () => {
createGameRoom();
});

// Create a game room
function createGameRoom() {
// Generate a unique room ID
roomId = 'room-' + Date.now() + '-' + Math.floor(Math.random() * 1000);

// Set up room data
const roomData = {
player1: currentUser.uid,
player1Name: currentUserName,
player1Elo: currentUserElo,
player1Avatar: currentUserAvatar,
status: 'waiting',
created: Date.now(),
lastActivity: Date.now(),
fen: 'start' // Default starting position
};

// If opponent is selected, include their data
if (selectedOpponent) {
roomData.invitedPlayer = selectedOpponent;
roomData.invitedPlayerName = selectedOpponentName;
}

// Save to database
database.ref('chess_rooms/' + roomId).set(roomData)
.then(() => {
    // Show room section
    opponentSection.style.display = 'none';
    roomSection.style.display = 'block';
    
    // Generate and display room URL
    const roomUrl = `${window.location.origin}${window.location.pathname}?room=${roomId}`;
    roomUrlElement.textContent = roomUrl;
    
    // Set up listener for opponent joining
    setupRoomListener();
})
.catch((error) => {
    console.error('Error creating room:', error);
    alert('Error creating game room. Please try again.');
});
}

// Copy room URL to clipboard
copyUrlBtn.addEventListener('click', () => {
const roomUrl = roomUrlElement.textContent;
navigator.clipboard.writeText(roomUrl)
.then(() => {
    copyUrlBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
    setTimeout(() => {
        copyUrlBtn.innerHTML = '<i class="fas fa-copy"></i> Copy Link';
    }, 2000);
})
.catch((error) => {
    console.error('Error copying URL:', error);
    alert('Error copying URL. Please try to copy it manually.');
});
});

// Cancel room
cancelRoomBtn.addEventListener('click', () => {
if (roomId) {
database.ref('chess_rooms/' + roomId).update({
    status: 'cancelled'
})
.then(() => {
    roomSection.style.display = 'none';
    opponentSection.style.display = 'block';
})
.catch((error) => {
    console.error('Error cancelling room:', error);
});
}
});

// Listen for opponent joining the room
function setupRoomListener() {
database.ref('chess_rooms/' + roomId).on('value', (snapshot) => {
const roomData = snapshot.val();

if (!roomData) {
    // Room was deleted
    alert('The game room no longer exists.');
    roomSection.style.display = 'none';
    opponentSection.style.display = 'block';
    return;
}

if (roomData.status === 'active' && roomData.player2) {
    // Opponent joined, start the game
    roomSection.style.display = 'none';
    gameSection.style.display = 'block';
    
    // Set opponent info
    selectedOpponent = roomData.player2;
    selectedOpponentName = roomData.player2Name;
    selectedOpponentElo = roomData.player2Elo;
    selectedOpponentAvatar = roomData.player2Avatar;
    
    // Update player info display
    updatePlayerInfo();
    
    // Initialize game
    playerColor = 'white'; // Room creator is white
    initGame();
    
    // Add system message
    addSystemMessage(`${selectedOpponentName} joined the game.`);
    addSystemMessage('Game started! You are playing as White.');
    
    // Set up game event listeners
    setupGameListeners();
}
});
}

// Update player info display
function updatePlayerInfo() {
opponentNameElement.textContent = selectedOpponentName;
opponentEloElement.textContent = `ELO: ${selectedOpponentElo}`;
playerNameElement.textContent = currentUserName;
playerEloElement.textContent = `ELO: ${currentUserElo}`;

if (selectedOpponentAvatar) {
opponentAvatarElement.src = selectedOpponentAvatar;
}

if (currentUserAvatar) {
playerAvatarElement.src = currentUserAvatar;
}
}

// Initialize chess game
function initGame(initialFen) {
game = new Chess(initialFen || 'start');

const config = {
draggable: true,
position: initialFen || 'start',
orientation: playerColor,
onDragStart: onDragStart,
onDrop: onDrop,
onSnapEnd: onSnapEnd
};

board = Chessboard('board', config);

gameStarted = true;
updateStatus();
isMyTurn = playerColor === 'white'; // White moves first
updateWaitingMessage();

// Load move history if available
if (roomId) {
database.ref('chess_rooms/' + roomId + '/moves').once('value')
    .then((snapshot) => {
        const moves = snapshot.val();
        if (moves) {
            // Display moves in the history
            let moveList = '';
            for (let i = 0; i < moves.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = moves[i] ? moves[i].san : '';
                const blackMove = moves[i + 1] ? moves[i + 1].san : '';
                moveList += `<li>${moveNumber}. ${whiteMove} ${blackMove}</li>`;
            }
            moveHistoryElement.innerHTML = moveList;
        }
    });

// Load chat history
database.ref('chess_rooms/' + roomId + '/chat').once('value')
    .then((snapshot) => {
        const messages = snapshot.val();
        if (messages) {
            // Clear existing messages
            chatMessagesElement.innerHTML = '';
            chatMessages = [];
            
            // Add all messages
            Object.values(messages).forEach(msg => {
                if (msg.sender === 'system') {
                    addSystemMessage(msg.text);
                } else if (msg.sender === currentUser.uid) {
                    addMessage(msg.text, currentUserName, true);
                } else {
                    addMessage(msg.text, selectedOpponentName, false);
                }
            });
        }
    });
}
}

// Check if a move is legal
function onDragStart(source, piece) {
// Do not pick up pieces if the game is over or not your turn
if (game.game_over() || !isMyTurn) return false;

// Only pick up your own pieces
if ((playerColor === 'white' && piece.search(/^b/) !== -1) ||
(playerColor === 'black' && piece.search(/^w/) !== -1)) {
return false;
}

return true;
}

// Handle piece drop
function onDrop(source, target) {
// Check if the move is legal
const move = game.move({
from: source,
to: target,
promotion: 'q' // Always promote to queen for simplicity
});

// If move is illegal, return piece to source square
if (move === null) return 'snapback';

// Move is legal, save to database
saveMove(move);

// Toggle turn
isMyTurn = false;
updateWaitingMessage();

// Update status
updateStatus();

return;
}

// Update board position after piece snap animation
function onSnapEnd() {
board.position(game.fen());
}

// Save move to Firebase
function saveMove(move) {
if (!roomId) return;

// Get current moves array
database.ref('chess_rooms/' + roomId + '/moves').once('value')
.then((snapshot) => {
    let moves = snapshot.val() || [];
    
    // Add new move
    moves.push({
        from: move.from,
        to: move.to,
        piece: move.piece,
        san: move.san,
        color: move.color,
        flags: move.flags,
        timestamp: Date.now()
    });
    
    // Update moves in database
    return database.ref('chess_rooms/' + roomId).update({
        moves: moves,
        fen: game.fen(),
        lastActivity: Date.now(),
        lastMoveBy: currentUser.uid
    });
})
.then(() => {
    // Update move history display
    updateMoveHistory();
    
    // Check for game over after move is saved
    checkGameStatus();
})
.catch((error) => {
    console.error('Error saving move:', error);
});
}

// Update move history display
function updateMoveHistory() {
database.ref('chess_rooms/' + roomId + '/moves').once('value')
.then((snapshot) => {
    const moves = snapshot.val();
    if (!moves) return;
    
    let moveList = '';
    for (let i = 0; i < moves.length; i += 2) {
        const moveNumber = Math.floor(i / 2) + 1;
        const whiteMove = moves[i] ? moves[i].san : '';
        const blackMove = moves[i + 1] ? moves[i + 1].san : '';
        moveList += `<li>${moveNumber}. ${whiteMove} ${blackMove}</li>`;
    }
    moveHistoryElement.innerHTML = moveList;
    
    // Scroll to bottom of move history
    moveHistoryElement.scrollTop = moveHistoryElement.scrollHeight;
});
}

// Setup game event listeners
function setupGameListeners() {
// Listen for game state changes
database.ref('chess_rooms/' + roomId).on('value', (snapshot) => {
const roomData = snapshot.val();

if (!roomData) {
    // Room was deleted
    alert('The game room no longer exists.');
    gameSection.style.display = 'none';
    opponentSection.style.display = 'block';
    return;
}

// Update game state if changed by opponent
if (roomData.lastMoveBy && roomData.lastMoveBy !== currentUser.uid) {
    // Load the latest game position
    game.load(roomData.fen);
    board.position(game.fen());
    
    // Update move history
    updateMoveHistory();
    
    // It's now my turn
    isMyTurn = true;
    updateWaitingMessage();
    
    // Update game status
    updateStatus();
}

// Check for draw offer
if (roomData.drawOffer && roomData.drawOffer !== currentUser.uid && !drawOffered) {
    drawOffered = true;
    if (confirm(`${selectedOpponentName} offers a draw. Accept?`)) {
        acceptDraw();
    } else {
        declineDraw();
    }
}

// Check for game over
if (roomData.result && !roomData.resultHandled) {
    handleGameEnd(roomData.result, roomData.reason);
}
});

// Listen for chat messages
database.ref('chess_rooms/' + roomId + '/chat').on('child_added', (snapshot) => {
const message = snapshot.val();

// Display only new messages
if (!chatMessages.some(msg => msg.timestamp === message.timestamp)) {
    chatMessages.push(message);
    
    if (message.sender === 'system') {
        addSystemMessage(message.text);
    } else if (message.sender === currentUser.uid) {
        // Own message already displayed
    } else {
        addMessage(message.text, selectedOpponentName, false);
    }
}
});
}

// Update game status display
function updateStatus() {
let status = '';

if (game.in_checkmate()) {
status = 'Game over, ' + (game.turn() === 'w' ? 'black' : 'white') + ' wins by checkmate';
endGame(game.turn() === 'w' ? 'black' : 'white', 'checkmate');
} else if (game.in_draw()) {
status = 'Game over, drawn position';
let reason = '';
if (game.in_stalemate()) {
    reason = 'stalemate';
} else if (game.in_threefold_repetition()) {
    reason = 'repetition';
} else if (game.insufficient_material()) {
    reason = 'insufficient material';
} else {
    reason = '50-move rule';
}
endGame('draw', reason);
} else {
status = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
if (game.in_check()) {
    status += ', ' + (game.turn() === 'w' ? 'White' : 'Black') + ' is in check';
}
}

statusElement.textContent = status;
}

// Update waiting message based on turn
function updateWaitingMessage() {
if (isMyTurn) {
waitingMessage.style.display = 'none';
} else {
waitingMessage.style.display = 'block';
waitingMessage.innerHTML = `Waiting for ${selectedOpponentName} to make a move... <span class="player-turn-indicator ${playerColor === 'white' ? 'turn-black' : 'turn-white'}"></span>`;
}
}

// Check game status after move
function checkGameStatus() {
if (game.game_over()) {
let result = '';
let reason = '';

if (game.in_checkmate()) {
    result = game.turn() === 'w' ? 'black' : 'white';
    reason = 'checkmate';
} else if (game.in_draw()) {
    result = 'draw';
    if (game.in_stalemate()) {
        reason = 'stalemate';
    } else if (game.in_threefold_repetition()) {
        reason = 'repetition';
    } else if (game.insufficient_material()) {
        reason = 'insufficient material';
    } else {
        reason = '50-move rule';
    }
}

if (result) {
    endGame(result, reason);
}
}
}

// End the game and update database
function endGame(result, reason) {
if (!roomId || !gameStarted) return;

// Update room status in database
database.ref('chess_rooms/' + roomId).update({
status: 'completed',
result: result,
reason: reason,
endTime: Date.now()
})
.then(() => {
handleGameEnd(result, reason);
})
.catch((error) => {
console.error('Error ending game:', error);
});
}

// Handle game end UI and ELO calculation
function handleGameEnd(result, reason) {
// Disable board
board.draggable = false;
isMyTurn = false;
gameStarted = false;
waitingMessage.style.display = 'none';

// Calculate ELO changes
let myNewElo = currentUserElo;
let opponentNewElo = selectedOpponentElo;
let eloChange = 0;
let resultText = '';

// Expected score calculation (ELO formula)
const calculateExpectedScore = (playerRating, opponentRating) => {
return 1 / (1 + Math.pow(10, (opponentRating - playerRating) / 400));
};

// Calculate expected scores
const myExpectedScore = calculateExpectedScore(currentUserElo, selectedOpponentElo);
const opponentExpectedScore = calculateExpectedScore(selectedOpponentElo, currentUserElo);

// K-factor (importance of match)
const K = 32;

// Calculate actual score
let myActualScore = 0.5; // Default for draw
if (result === playerColor) {
myActualScore = 1.0; // Win
} else if (result !== 'draw') {
myActualScore = 0.0; // Loss
}

// Calculate ELO change
eloChange = Math.round(K * (myActualScore - myExpectedScore));
myNewElo = currentUserElo + eloChange;
opponentNewElo = selectedOpponentElo - eloChange;

// Update UI
if (result === playerColor) {
resultText = `You won by ${reason}!`;
} else if (result === 'draw') {
resultText = `Game drawn (${reason}).`;
} else {
resultText = `You lost by ${reason}.`;
}

// Update player stats in database
database.ref('users/' + currentUser.uid).once('value')
.then((snapshot) => {
    const userData = snapshot.val() || {};
    const stats = {
        elo: myNewElo,
        gamesPlayed: (userData.gamesPlayed || 0) + 1,
        wins: (userData.wins || 0) + (result === playerColor ? 1 : 0),
        losses: (userData.losses || 0) + (result !== playerColor && result !== 'draw' ? 1 : 0),
        draws: (userData.draws || 0) + (result === 'draw' ? 1 : 0)
    };
    
    return database.ref('users/' + currentUser.uid).update(stats);
})
.then(() => {
    // Update opponent stats
    return database.ref('users/' + selectedOpponent).once('value');
})
.then((snapshot) => {
    const opponentData = snapshot.val() || {};
    const opponentStats = {
        elo: opponentNewElo,
        gamesPlayed: (opponentData.gamesPlayed || 0) + 1,
        wins: (opponentData.wins || 0) + (result !== playerColor && result !== 'draw' ? 1 : 0),
        losses: (opponentData.losses || 0) + (result === playerColor ? 1 : 0),
        draws: (opponentData.draws || 0) + (result === 'draw' ? 1 : 0)
    };
    
    return database.ref('users/' + selectedOpponent).update(opponentStats);
})
.then(() => {
    // Mark result as handled
    return database.ref('chess_rooms/' + roomId).update({
        resultHandled: true
    });
})
.then(() => {
    // Display game results
    gameResultsElement.style.display = 'block';
    resultDetailsElement.innerHTML = `
        <div class="result-detail">${resultText}</div>
        <div class="result-detail">Your new ELO: ${myNewElo} 
            <span class="elo-change ${eloChange >= 0 ? 'positive-elo' : 'negative-elo'}">
                (${eloChange >= 0 ? '+' : ''}${eloChange})
            </span>
        </div>
        <div class="result-detail">${selectedOpponentName}'s new ELO: ${opponentNewElo}</div>
    `;
    
    // Add system message about game end
    addSystemMessage(`Game over. ${resultText}`);
})
.catch((error) => {
    console.error('Error updating stats:', error);
});

// Save game to history
saveGameToHistory(result, reason, eloChange);
}

// Save completed game to history
function saveGameToHistory(result, reason, eloChange) {
const gameHistory = {
whitePlayer: playerColor === 'white' ? currentUser.uid : selectedOpponent,
whitePlayerName: playerColor === 'white' ? currentUserName : selectedOpponentName,
blackPlayer: playerColor === 'black' ? currentUser.uid : selectedOpponent,
blackPlayerName: playerColor === 'black' ? currentUserName : selectedOpponentName,
winner: result !== 'draw' ? (result === 'white' ? 'white' : 'black') : 'draw',
reason: reason,
startTime: game.header().Date || Date.now(),
endTime: Date.now(),
eloChange: eloChange,
roomId: roomId,
pgn: game.pgn()
};

// Save to game history collection
database.ref('game_history').push(gameHistory)
.catch((error) => {
    console.error('Error saving game history:', error);
});
}

// Resign game
resignBtn.addEventListener('click', () => {
if (!gameStarted) return;

if (confirm('Are you sure you want to resign?')) {
// Determine winner (opponent)
const result = playerColor === 'white' ? 'black' : 'white';
endGame(result, 'resignation');

// Add system message
const messageData = {
    sender: 'system',
    text: `${currentUserName} resigned.`,
    timestamp: Date.now()
};
database.ref('chess_rooms/' + roomId + '/chat').push(messageData);
}
});

// Offer draw
offerDrawBtn.addEventListener('click', () => {
if (!gameStarted) return;

// Record draw offer in database
database.ref('chess_rooms/' + roomId).update({
drawOffer: currentUser.uid,
drawOfferTime: Date.now()
})
.then(() => {
// Add system message
const messageData = {
    sender: 'system',
    text: `${currentUserName} offered a draw.`,
    timestamp: Date.now()
};
return database.ref('chess_rooms/' + roomId + '/chat').push(messageData);
})
.then(() => {
// Notify the current player
alert('Draw offer sent. Waiting for opponent response.');
})
.catch((error) => {
console.error('Error offering draw:', error);
});
});

// Accept draw
function acceptDraw() {
// End game with draw result
endGame('draw', 'agreement');

// Clear draw offer
database.ref('chess_rooms/' + roomId).update({
drawOffer: null
});

// Add system message
const messageData = {
sender: 'system',
text: `${currentUserName} accepted the draw offer.`,
timestamp: Date.now()
};
database.ref('chess_rooms/' + roomId + '/chat').push(messageData);

drawOffered = false;
}

// Decline draw
function declineDraw() {
// Clear draw offer
database.ref('chess_rooms/' + roomId).update({
drawOffer: null
});

// Add system message
const messageData = {
sender: 'system',
text: `${currentUserName} declined the draw offer.`,
timestamp: Date.now()
};
database.ref('chess_rooms/' + roomId + '/chat').push(messageData);

drawOffered = false;
}

// New game button
newGameBtn.addEventListener('click', () => {
if (confirm('Are you sure you want to start a new game with the same opponent?')) {
// Create a new room with the same opponent
createNewGameWithSameOpponent();
}
});

// Create new game with same opponent
function createNewGameWithSameOpponent() {
// Generate a new room ID
const newRoomId = 'room-' + Date.now() + '-' + Math.floor(Math.random() * 1000);

// Switch colors for the new game
const newPlayerColor = playerColor === 'white' ? 'black' : 'white';

// Set up room data
const roomData = {
player1: currentUser.uid,
player1Name: currentUserName,
player1Elo: currentUserElo,
player1Avatar: currentUserAvatar,
invitedPlayer: selectedOpponent,
invitedPlayerName: selectedOpponentName,
status: 'waiting',
created: Date.now(),
lastActivity: Date.now(),
fen: 'start',
previousGameId: roomId
};

// Save to database
database.ref('chess_rooms/' + newRoomId).set(roomData)
.then(() => {
    // Hide results
    gameResultsElement.style.display = 'none';
    
    // Show room section
    gameSection.style.display = 'none';
    roomSection.style.display = 'block';
    
    // Update room ID
    roomId = newRoomId;
    
    // Generate and display room URL
    const roomUrl = `${window.location.origin}${window.location.pathname}?room=${roomId}`;
    roomUrlElement.textContent = roomUrl;
    
    // Set up listener for opponent joining
    setupRoomListener();
    
    // Add system message to previous game chat
    const messageData = {
        sender: 'system',
        text: `${currentUserName} created a new game.`,
        timestamp: Date.now()
    };
    database.ref('chess_rooms/' + roomId + '/chat').push(messageData);
})
.catch((error) => {
    console.error('Error creating new game:', error);
    alert('Error creating new game. Please try again.');
});
}

// Play again button
playAgainBtn.addEventListener('click', () => {
// Create a new game with the same opponent
createNewGameWithSameOpponent();
});

// Find new opponent button
findNewOpponentBtn.addEventListener('click', () => {
// Go back to opponent selection
gameResultsElement.style.display = 'none';
gameSection.style.display = 'none';

// Reset game state
game = null;
board = null;
selectedOpponent = null;
selectedOpponentName = null;
gameStarted = false;

// Show opponent selection
loadOpponents();
opponentSection.style.display = 'block';
});

// Chat functionality
chatSendBtn.addEventListener('click', sendChatMessage);

chatInput.addEventListener('keypress', (event) => {
if (event.key === 'Enter') {
sendChatMessage();
}
});

function sendChatMessage() {
const text = chatInput.value.trim();
if (!text || !roomId) return;

// Add message to UI
addMessage(text, currentUserName, true);

// Save message to database
const messageData = {
sender: currentUser.uid,
text: text,
timestamp: Date.now()
};

database.ref('chess_rooms/' + roomId + '/chat').push(messageData)
.then(() => {
    // Clear input
    chatInput.value = '';
})
.catch((error) => {
    console.error('Error sending message:', error);
});
}

function addMessage(text, sender, isSelf) {
const messageElement = document.createElement('div');
messageElement.className = `message ${isSelf ? 'message-self' : 'message-other'}`;

messageElement.innerHTML = `
<div class="message-sender">${sender}</div>
<div class="message-text">${escapeHtml(text)}</div>
`;

chatMessagesElement.appendChild(messageElement);

// Scroll to bottom
chatMessagesElement.scrollTop = chatMessagesElement.scrollHeight;
}

function addSystemMessage(text) {
const messageElement = document.createElement('div');
messageElement.className = 'message message-system';
messageElement.textContent = text;

chatMessagesElement.appendChild(messageElement);

// Scroll to bottom
chatMessagesElement.scrollTop = chatMessagesElement.scrollHeight;
}

// Helper function to escape HTML
function escapeHtml(unsafe) {
return unsafe
.replace(/&/g, "&amp;")
.replace(/</g, "&lt;")
.replace(/>/g, "&gt;")
.replace(/"/g, "&quot;")
.replace(/'/g, "&#039;");
}

// Toggle mobile menu
function toggleMenu() {
const menu = document.querySelector('nav ul');
menu.classList.toggle('active');
}

// Clean up inactive games
function cleanupInactiveGames() {
const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);

// Find inactive waiting rooms
database.ref('chess_rooms')
.orderByChild('lastActivity')
.endAt(oneDayAgo)
.once('value')
.then((snapshot) => {
    snapshot.forEach((childSnapshot) => {
        const roomData = childSnapshot.val();
        
        // Only cleanup waiting or cancelled rooms
        if (roomData.status === 'waiting' || roomData.status === 'cancelled') {
            database.ref('chess_rooms/' + childSnapshot.key).update({
                status: 'expired'
            });
        }
    });
})
.catch((error) => {
    console.error('Error cleaning up inactive games:', error);
});
}

// Periodic cleanup
setInterval(cleanupInactiveGames, 60 * 60 * 1000); // Run every hour

// Check for authentication state changes
auth.onAuthStateChanged((user) => {
if (user) {
// User is signed in
currentUser = user;

// Get user data
database.ref('users/' + user.uid).once('value')
    .then((snapshot) => {
        const userData = snapshot.val();
        if (userData) {
            currentUserName = userData.name || 'Anonymous Player';
            currentUserElo = userData.elo || 1200;
            currentUserAvatar = userData.avatar || 'https://i.ibb.co/Vwt7cPq/the-dark-knights-ibns-sina-chess-club-logo-1.png';
            
            // Check if we're already in a game room
            if (!roomId) {
                // Show opponent selection
                document.getElementById('auth-section').style.display = 'none';
                loadOpponents();
                opponentSection.style.display = 'block';
            }
        }
    })
    .catch((error) => {
        console.error('Error getting user data:', error);
    });
} else {
// User is signed out
document.getElementById('auth-section').style.display = 'block';
opponentSection.style.display = 'none';
gameSection.style.display = 'none';
roomSection.style.display = 'none';
gameResultsElement.style.display = 'none';

// Reset state
currentUser = null;
currentUserName = null;
selectedOpponent = null;
selectedOpponentName = null;
}
});

// Initialize - check for room ID parameter
window.addEventListener('load', () => {
const urlParams = new URLSearchParams(window.location.search);
const urlRoomId = urlParams.get('room');

if (urlRoomId) {
roomId = urlRoomId;
}
});

// Handle browser tab closing or navigation away
window.addEventListener('beforeunload', () => {
if (roomId && currentUser) {
// If game is in progress, don't perform cleanup
// The reconnection logic will handle it
if (gameStarted) {
    return;
}

// If it's a waiting room I created, cancel it
database.ref('chess_rooms/' + roomId).once('value')
    .then((snapshot) => {
        const roomData = snapshot.val();
        if (roomData && roomData.status === 'waiting' && roomData.player1 === currentUser.uid) {
            database.ref('chess_rooms/' + roomId).update({
                status: 'cancelled'
            });
        }
    });
}
});

// ELO Rating System implementation for chess game
function updateEloRatings(gameResult) {
// Get the players involved in the game
const whitePlayer = playerColor === 'white' ? currentUser.uid : selectedOpponent;
const blackPlayer = playerColor === 'black' ? currentUser.uid : selectedOpponent;

// Get their current ratings
let whiteElo = playerColor === 'white' ? currentUserElo : selectedOpponentElo;
let blackElo = playerColor === 'black' ? currentUserElo : selectedOpponentElo;

// Determine the actual outcome of the game (1 for white win, 0.5 for draw, 0 for black win)
let actualScore;
if (gameResult === 'white') {
actualScore = 1.0;
} else if (gameResult === 'black') {
actualScore = 0.0;
} else { // draw
actualScore = 0.5;
}

// Calculate expected outcome based on ELO formula
const expectedScore = calculateExpectedScore(whiteElo, blackElo);

// K-factor determines the maximum possible change in rating
// Standard K values:
// 40 for new players (under 30 games)
// 20 for established players
// 10 for masters (ELO > 2400)
let kFactor = 32; // Using 32 as a standard K-factor for club players

// Calculate rating changes
const ratingChange = Math.round(kFactor * (actualScore - expectedScore));

// Update the ratings
const newWhiteElo = whiteElo + ratingChange;
const newBlackElo = blackElo - ratingChange;

// Create a game record for history
const gameRecord = {
whitePlayer: whitePlayer,
whitePlayerName: playerColor === 'white' ? currentUserName : selectedOpponentName,
blackPlayer: blackPlayer,
blackPlayerName: playerColor === 'black' ? currentUserName : selectedOpponentName,
whiteElo: whiteElo,
blackElo: blackElo,
newWhiteElo: newWhiteElo,
newBlackElo: newBlackElo,
ratingChange: ratingChange,
result: gameResult,
date: new Date().toISOString(),
moves: game.history(),
pgn: game.pgn(),
roomId: roomId
};

// Save game record to database
const gameHistoryRef = database.ref('game_history').push();
gameHistoryRef.set(gameRecord)
.then(() => {
    console.log('Game history saved with ID:', gameHistoryRef.key);
    
    // Update player ratings in database
    const updates = {};
    updates[`users/${whitePlayer}/elo`] = newWhiteElo;
    updates[`users/${blackPlayer}/elo`] = newBlackElo;
    
    // Update game statistics
    if (whitePlayer === currentUser.uid) {
        if (gameResult === 'white') {
            updates[`users/${whitePlayer}/wins`] = firebase.database.ServerValue.increment(1);
            updates[`users/${blackPlayer}/losses`] = firebase.database.ServerValue.increment(1);
        } else if (gameResult === 'black') {
            updates[`users/${whitePlayer}/losses`] = firebase.database.ServerValue.increment(1);
            updates[`users/${blackPlayer}/wins`] = firebase.database.ServerValue.increment(1);
        } else {
            updates[`users/${whitePlayer}/draws`] = firebase.database.ServerValue.increment(1);
            updates[`users/${blackPlayer}/draws`] = firebase.database.ServerValue.increment(1);
        }
    } else {
        if (gameResult === 'white') {
            updates[`users/${whitePlayer}/wins`] = firebase.database.ServerValue.increment(1);
            updates[`users/${blackPlayer}/losses`] = firebase.database.ServerValue.increment(1);
        } else if (gameResult === 'black') {
            updates[`users/${whitePlayer}/losses`] = firebase.database.ServerValue.increment(1);
            updates[`users/${blackPlayer}/wins`] = firebase.database.ServerValue.increment(1);
        } else {
            updates[`users/${whitePlayer}/draws`] = firebase.database.ServerValue.increment(1);
            updates[`users/${blackPlayer}/draws`] = firebase.database.ServerValue.increment(1);
        }
    }
    
    // Update games played count
    updates[`users/${whitePlayer}/gamesPlayed`] = firebase.database.ServerValue.increment(1);
    updates[`users/${blackPlayer}/gamesPlayed`] = firebase.database.ServerValue.increment(1);
    
    // Apply all updates in a single operation
    return database.ref().update(updates);
})
.then(() => {
    console.log('Player ratings updated successfully');
    
    // Update local variables
    if (whitePlayer === currentUser.uid) {
        currentUserElo = newWhiteElo;
        selectedOpponentElo = newBlackElo;
    } else {
        selectedOpponentElo = newWhiteElo;
        currentUserElo = newBlackElo;
    }
    
    // Update UI
    playerEloElement.textContent = `ELO: ${currentUserElo}`;
    opponentEloElement.textContent = `ELO: ${selectedOpponentElo}`;
    
    // Show rating change in the game results
    const eloChangeText = playerColor === 'white' ? 
(ratingChange >= 0 ? `+${ratingChange}` : ratingChange) : 
(ratingChange >= 0 ? `-${ratingChange}` : `+${-ratingChange}`);

const eloChangeClass = playerColor === 'white' ? 
(ratingChange >= 0 ? 'positive-elo' : 'negative-elo') : 
(ratingChange >= 0 ? 'negative-elo' : 'positive-elo');

document.querySelector('.elo-change').textContent = eloChangeText;
document.querySelector('.elo-change').className = `elo-change ${eloChangeClass}`;
})
.catch((error) => {
console.error('Error updating ratings:', error);
});
}

// Calculate expected score based on ELO ratings
function calculateExpectedScore(rating1, rating2) {
return 1 / (1 + Math.pow(10, (rating2 - rating1) / 400));
}

// Initialize the app
document.addEventListener('DOMContentLoaded', () => {
// Check for authentication first
auth.onAuthStateChanged((user) => {
if (user) {
    // Already handled in the auth state change listener above
} else if (!roomId) {
    // Show QR scanner if not trying to join a room
    document.getElementById('auth-section').style.display = 'block';
    document.getElementById('qr-scanner-btn').focus();
}
});

// Set up chat input focus when chat is clicked
document.getElementById('chat-container').addEventListener('click', () => {
chatInput.focus();
});

// Initialize tooltips
const tooltips = document.querySelectorAll('[data-tooltip]');
tooltips.forEach(tooltip => {
tooltip.addEventListener('mouseenter', (e) => {
    const tip = document.createElement('div');
    tip.className = 'tooltip';
    tip.textContent = e.target.dataset.tooltip;
    document.body.appendChild(tip);
    
    const rect = e.target.getBoundingClientRect();
    tip.style.left = rect.left + (rect.width / 2) - (tip.offsetWidth / 2) + 'px';
    tip.style.top = rect.top - tip.offsetHeight - 5 + 'px';
    
    e.target.addEventListener('mouseleave', () => {
        document.body.removeChild(tip);
    }, { once: true });
});
});
});

 </script>
</body>
</html>
